<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes By Example</title>
    <link>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/</link>
    <description>Recent content on Kubernetes By Example</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/cloud-practice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/cloud-practice/</guid>
      <description>Guided Exercise: Configuring Cloud Applications Injecting Configuration Data into an Application In this exercise, you will use configuration maps and secrets to externalize the configuration for a containerized application.
Outcomes You should be able to:
  Deploy a simple Node.js-based application that prints configuration details from environment variables and files.
  Inject configuration data into the container using configuration maps and secrets.
  Change the data in the configuration map and verify that the application picks up the changed values.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/cloud/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/cloud/</guid>
      <description>Configuring Cloud Applications Objectives After completing this section, you should be able to create Kubernetes resources holding application configuration and secrets, and how to make that configuration available to running applications.
Externalizing Application Configuration in Kubernetes Developers configure their applications through a combination of environment variables, command-line arguments, and configuration files. When deploying applications to Kubernetes, configuration management presents a challenge due to the immutable nature of containers. When running containerized applications, decoupling application and configuration code is of a higher priority than in traditional deployments.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/limit-practice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/limit-practice/</guid>
      <description>Guided Exercise: Limiting Resource Usage Outcomes You should be able to use the Kubernetes command-line interface to:
  Configure an application to specify resource requests for CPU and memory usage.
  Modify an application to work within existing cluster restrictions.
  Prerequisites You need a working Kubernetes cluster, and your kubectl command must be configured to communicate with the cluster.
Make sure your kubectl context refers to a namespace where you have enough permissions, usually username-dev or username-stage.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/limit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/limit/</guid>
      <description>Limiting Resource Usage Objectives After completing this section, you should be able to leverage how to avoid applications overusing system resources.
Defining Resource Requests and Limits for Pods A pod definition can include both resource requests and resource limits:
 Resource requests Used for scheduling and indicating that a pod cannot run with less than the specified amount of compute resources. The scheduler tries to find a node with sufficient compute resources to satisfy the requests.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/probes-practice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/probes-practice/</guid>
      <description>Guided Exercise: Liveness, Readiness, and Startup Probes Activating Probes In this exercise, you will configure liveness and readiness probes to monitor the health of an application deployed to your Kubernetes cluster.
The application you deploy in this exercise exposes two HTTP GET endpoints:
  The /healthz endpoint responds with a 200 HTTP status code when the application pod can receive requests.
The endpoint indicates that the application pod is healthy and reachable.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/probes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tonejito.github.io/kbe/learning-paths/application-development/lesson-4/probes/</guid>
      <description>Liveness, Readiness, and Startup Probes Objectives After completing this section, you should be able to review how Kubernetes evaluates application health status via probes and automatic application restart.
Kubernetes Readiness and Liveness Probes Applications can become unreliable for a variety of reasons, for example:
 Temporary connection loss Configuration errors Application errors  Developers can use probes to monitor their applications. Probes make developers aware of events such as application status, resource usage, and errors.</description>
    </item>
    
  </channel>
</rss>
